Index: utils/skiplist.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\n * Copyright 2017 Dgraph Labs, Inc. and Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\nAdapted from RocksDB inline skiplist.\n\nKey differences:\n- No optimization for sequential inserts (no \"prev\").\n- No custom comparator.\n- Support overwrites. This requires care when we see the same key when inserting.\n  For RocksDB or LevelDB, overwrites are implemented as a newer sequence number in the key, so\n\tthere is no need for values. We don't intend to support versioning. In-place updates of values\n\twould be more efficient.\n- We discard all non-concurrent code.\n- We do not support Splices. This simplifies the code a lot.\n- No AllocateNode or other pointer arithmetic.\n- We combine the findLessThan, findGreaterOrEqual, etc into one function.\n*/\n\npackage utils\n\nimport (\n\t\"github.com/pkg/errors\"\n\t\"log\"\n\t\"math\"\n\t\"sync/atomic\"\n\t_ \"unsafe\"\n)\n\nconst (\n\tmaxHeight      = 20\n\theightIncrease = math.MaxUint32 / 3\n)\n\ntype node struct {\n\t// Multiple parts of the value are encoded as a single uint64 so that it\n\t// can be atomically loaded and stored:\n\t//   value offset: uint32 (bits 0-31)\n\t//   value size  : uint16 (bits 32-63)\n\tvalue uint64\n\n\t// A byte slice is 24 bytes. We are trying to save space here.\n\tkeyOffset uint32 // Immutable. No need to lock to access key.\n\tkeySize   uint16 // Immutable. No need to lock to access key.\n\n\t// Height of the tower.\n\theight uint16\n\n\t// Most nodes do not need to use the full height of the tower, since the\n\t// probability of each successive level decreases exponentially. Because\n\t// these elements are never accessed, they do not need to be allocated.\n\t// Therefore, when a node is allocated in the arena, its memory footprint\n\t// is deliberately truncated to not include unneeded tower elements.\n\t//\n\t// All accesses to elements should use CAS operations, with no need to lock.\n\ttower [maxHeight]uint32\n}\n\ntype Skiplist struct {\n\theight     int32 // Current height. 1 <= height <= kMaxHeight. CAS.\n\theadOffset uint32\n\tref        int32\n\tarena      *Arena\n\tOnClose    func()\n}\n\n// IncrRef increases the refcount\nfunc (s *Skiplist) IncrRef() {\n\tatomic.AddInt32(&s.ref, 1)\n}\n\n// DecrRef decrements the refcount, deallocating the Skiplist when done using it\nfunc (s *Skiplist) DecrRef() {\n\tnewRef := atomic.AddInt32(&s.ref, -1)\n\tif newRef > 0 {\n\t\treturn\n\t}\n\tif s.OnClose != nil {\n\t\ts.OnClose()\n\t}\n\n\t// Indicate we are closed. Good for testing.  Also, lets GC reclaim memory. Race condition\n\t// here would suggest we are accessing skiplist when we are supposed to have no reference!\n\ts.arena = nil\n}\n\nfunc newNode(arena *Arena, key []byte, v ValueStruct, height int) *node {\n\t// The base level is already allocated in the node struct.\n\tnodeOffset := arena.putNode(height)\n\tkeyOffset := arena.putKey(key)\n\tval := encodeValue(arena.putVal(v), v.EncodedSize())\n\n\tnode := arena.getNode(nodeOffset)\n\tnode.keyOffset = keyOffset\n\tnode.keySize = uint16(len(key))\n\tnode.height = uint16(height)\n\tnode.value = val\n\treturn node\n}\n\nfunc encodeValue(valOffset uint32, valSize uint32) uint64 {\n\treturn uint64(valSize)<<32 | uint64(valOffset)\n}\n\nfunc decodeValue(value uint64) (valOffset uint32, valSize uint32) {\n\tvalOffset = uint32(value)\n\tvalSize = uint32(value >> 32)\n\treturn\n}\n\n// NewSkiplist makes a new empty skiplist, with a given arena size\nfunc NewSkiplist(arenaSize int64) *Skiplist {\n\tarena := newArena(arenaSize)\n\thead := newNode(arena, nil, ValueStruct{}, maxHeight)\n\tho := arena.getNodeOffset(head)\n\treturn &Skiplist{\n\t\theight:     1,\n\t\theadOffset: ho,\n\t\tarena:      arena,\n\t\tref:        1,\n\t}\n}\n\nfunc (s *node) getValueOffset() (uint32, uint32) {\n\tvalue := atomic.LoadUint64(&s.value)\n\treturn decodeValue(value)\n}\n\nfunc (s *node) key(arena *Arena) []byte {\n\treturn arena.getKey(s.keyOffset, s.keySize)\n}\n\nfunc (s *node) setValue(arena *Arena, vo uint64) {\n\tatomic.StoreUint64(&s.value, vo)\n}\n\nfunc (s *node) getNextOffset(h int) uint32 {\n\treturn atomic.LoadUint32(&s.tower[h])\n}\n\nfunc (s *node) casNextOffset(h int, old, val uint32) bool {\n\treturn atomic.CompareAndSwapUint32(&s.tower[h], old, val)\n}\n\n// Returns true if key is strictly > n.key.\n// If n is nil, this is an \"end\" marker and we return false.\n//func (s *Skiplist) keyIsAfterNode(key []byte, n *node) bool {\n//\tAssertTrue(n != s.head)\n//\treturn n != nil && CompareKeys(key, n.key) > 0\n//}\n\nfunc (s *Skiplist) randomHeight() int {\n\th := 1\n\tfor h < maxHeight && FastRand() <= heightIncrease {\n\t\th++\n\t}\n\treturn h\n}\n\nfunc (s *Skiplist) getNext(nd *node, height int) *node {\n\treturn s.arena.getNode(nd.getNextOffset(height))\n}\n\nfunc (s *Skiplist) getHead() *node {\n\treturn s.arena.getNode(s.headOffset)\n}\n\n// findNear finds the node near to key.\n// If less=true, it finds rightmost node such that node.key < key (if allowEqual=false) or\n// node.key <= key (if allowEqual=true).\n// If less=false, it finds leftmost node such that node.key > key (if allowEqual=false) or\n// node.key >= key (if allowEqual=true).\n// Returns the node found. The bool returned is true if the node has key equal to given key.\nfunc (s *Skiplist) findNear(key []byte, less bool, allowEqual bool) (*node, bool) {\n\tx := s.getHead()\n\tlevel := int(s.getHeight() - 1)\n\tfor {\n\t\t// Assume x.key < key.\n\t\tnext := s.getNext(x, level)\n\t\tif next == nil {\n\t\t\t// x.key < key < END OF LIST\n\t\t\tif level > 0 {\n\t\t\t\t// Can descend further to iterate closer to the end.\n\t\t\t\tlevel--\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// Level=0. Cannot descend further. Let's return something that makes sense.\n\t\t\tif !less {\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t\t// Try to return x. Make sure it is not a head node.\n\t\t\tif x == s.getHead() {\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t\treturn x, false\n\t\t}\n\n\t\tnextKey := next.key(s.arena)\n\t\tcmp := CompareKeys(key, nextKey)\n\t\tif cmp > 0 {\n\t\t\t// x.key < next.key < key. We can continue to move right.\n\t\t\tx = next\n\t\t\tcontinue\n\t\t}\n\t\tif cmp == 0 {\n\t\t\t// x.key < key == next.key.\n\t\t\tif allowEqual {\n\t\t\t\treturn next, true\n\t\t\t}\n\t\t\tif !less {\n\t\t\t\t// We want >, so go to base level to grab the next bigger note.\n\t\t\t\treturn s.getNext(next, 0), false\n\t\t\t}\n\t\t\t// We want <. If not base level, we should go closer in the next level.\n\t\t\tif level > 0 {\n\t\t\t\tlevel--\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\t// On base level. Return x.\n\t\t\tif x == s.getHead() {\n\t\t\t\treturn nil, false\n\t\t\t}\n\t\t\treturn x, false\n\t\t}\n\t\t// cmp < 0. In other words, x.key < key < next.\n\t\tif level > 0 {\n\t\t\tlevel--\n\t\t\tcontinue\n\t\t}\n\t\t// At base level. Need to return something.\n\t\tif !less {\n\t\t\treturn next, false\n\t\t}\n\t\t// Try to return x. Make sure it is not a head node.\n\t\tif x == s.getHead() {\n\t\t\treturn nil, false\n\t\t}\n\t\treturn x, false\n\t}\n}\n\n// findSpliceForLevel returns (outBefore, outAfter) with outBefore.key <= key <= outAfter.key.\n// The input \"before\" tells us where to start looking.\n// If we found a node with the same key, then we return outBefore = outAfter.\n// Otherwise, outBefore.key < key < outAfter.key.\nfunc (s *Skiplist) findSpliceForLevel(key []byte, before uint32, level int) (uint32, uint32) {\n\tfor {\n\t\t// Assume before.key < key.\n\t\tbeforeNode := s.arena.getNode(before)\n\t\tnext := beforeNode.getNextOffset(level)\n\t\tnextNode := s.arena.getNode(next)\n\t\tif nextNode == nil {\n\t\t\treturn before, next\n\t\t}\n\t\tnextKey := nextNode.key(s.arena)\n\t\tcmp := CompareKeys(key, nextKey)\n\t\tif cmp == 0 {\n\t\t\t// Equality case.\n\t\t\treturn next, next\n\t\t}\n\t\tif cmp < 0 {\n\t\t\t// before.key < key < next.key. We are done for this level.\n\t\t\treturn before, next\n\t\t}\n\t\tbefore = next // Keep moving right on this level.\n\t}\n}\n\nfunc (s *Skiplist) getHeight() int32 {\n\treturn atomic.LoadInt32(&s.height)\n}\n\n// Put inserts the key-value pair.\nfunc (s *Skiplist) Add(e *Entry) {\n\t// Since we allow overwrite, we may not need to create a new node. We might not even need to\n\t// increase the height. Let's defer these actions.\n\tkey, v := e.Key, ValueStruct{\n\t\tMeta:      e.Meta,\n\t\tValue:     e.Value,\n\t\tExpiresAt: e.ExpiresAt,\n\t\tVersion:   e.Version,\n\t}\n\n\tlistHeight := s.getHeight()\n\tvar prev [maxHeight + 1]uint32\n\tvar next [maxHeight + 1]uint32\n\n\tprev[listHeight] = s.headOffset\n\tfor i := int(listHeight) - 1; i >= 0; i-- {\n\t\t// Use higher level to speed up for current level.\n\t\tprev[i], next[i] = s.findSpliceForLevel(key, prev[i+1], i)\n\t\tif prev[i] == next[i] {\n\t\t\tvo := s.arena.putVal(v)\n\t\t\tencValue := encodeValue(vo, v.EncodedSize())\n\t\t\tprevNode := s.arena.getNode(prev[i])\n\t\t\tprevNode.setValue(s.arena, encValue)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// We do need to create a new node.\n\theight := s.randomHeight()\n\tx := newNode(s.arena, key, v, height)\n\n\t// Try to increase s.height via CAS.\n\tlistHeight = s.getHeight()\n\tfor height > int(listHeight) {\n\t\tif atomic.CompareAndSwapInt32(&s.height, listHeight, int32(height)) {\n\t\t\t// Successfully increased skiplist.height.\n\t\t\tbreak\n\t\t}\n\t\tlistHeight = s.getHeight()\n\t}\n\n\t// We always insert from the base level and up. After you add a node in base level, we cannot\n\t// create a node in the level above because it would have discovered the node in the base level.\n\tfor i := 0; i < height; i++ {\n\t\tfor {\n\t\t\tif s.arena.getNode(prev[i]) == nil {\n\t\t\t\tAssertTrue(i > 1) // This cannot happen in base level.\n\t\t\t\t// We haven't computed prev, next for this level because height exceeds old listHeight.\n\t\t\t\t// For these levels, we expect the lists to be sparse, so we can just search from head.\n\t\t\t\tprev[i], next[i] = s.findSpliceForLevel(key, s.headOffset, i)\n\t\t\t\t// Someone adds the exact same key before we are able to do so. This can only happen on\n\t\t\t\t// the base level. But we know we are not on the base level.\n\t\t\t\tAssertTrue(prev[i] != next[i])\n\t\t\t}\n\t\t\tx.tower[i] = next[i]\n\t\t\tpnode := s.arena.getNode(prev[i])\n\t\t\tif pnode.casNextOffset(i, next[i], s.arena.getNodeOffset(x)) {\n\t\t\t\t// Managed to insert x between prev[i] and next[i]. Go to the next level.\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// CAS failed. We need to recompute prev and next.\n\t\t\t// It is unlikely to be helpful to try to use a different level as we redo the search,\n\t\t\t// because it is unlikely that lots of nodes are inserted between prev[i] and next[i].\n\t\t\tprev[i], next[i] = s.findSpliceForLevel(key, prev[i], i)\n\t\t\tif prev[i] == next[i] {\n\t\t\t\tAssertTruef(i == 0, \"Equality can happen only on base level: %d\", i)\n\t\t\t\tvo := s.arena.putVal(v)\n\t\t\t\tencValue := encodeValue(vo, v.EncodedSize())\n\t\t\t\tprevNode := s.arena.getNode(prev[i])\n\t\t\t\tprevNode.setValue(s.arena, encValue)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Empty returns if the Skiplist is empty.\nfunc (s *Skiplist) Empty() bool {\n\treturn s.findLast() == nil\n}\n\n// findLast returns the last element. If head (empty list), we return nil. All the find functions\n// will NEVER return the head nodes.\nfunc (s *Skiplist) findLast() *node {\n\tn := s.getHead()\n\tlevel := int(s.getHeight()) - 1\n\tfor {\n\t\tnext := s.getNext(n, level)\n\t\tif next != nil {\n\t\t\tn = next\n\t\t\tcontinue\n\t\t}\n\t\tif level == 0 {\n\t\t\tif n == s.getHead() {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn n\n\t\t}\n\t\tlevel--\n\t}\n}\n\n// Get gets the value associated with the key. It returns a valid value if it finds equal or earlier\n// version of the same key.\nfunc (s *Skiplist) Search(key []byte) ValueStruct {\n\tn, _ := s.findNear(key, false, true) // findGreaterOrEqual.\n\tif n == nil {\n\t\treturn ValueStruct{}\n\t}\n\n\tnextKey := s.arena.getKey(n.keyOffset, n.keySize)\n\tif !SameKey(key, nextKey) {\n\t\treturn ValueStruct{}\n\t}\n\n\tvalOffset, valSize := n.getValueOffset()\n\tvs := s.arena.getVal(valOffset, valSize)\n\tvs.ExpiresAt = ParseTs(nextKey)\n\treturn vs\n}\n\n// NewIterator returns a skiplist iterator.  You have to Close() the iterator.\nfunc (s *Skiplist) NewSkipListIterator() Iterator {\n\ts.IncrRef()\n\treturn &SkipListIterator{list: s}\n}\n\n// MemSize returns the size of the Skiplist in terms of how much memory is used within its internal\n// arena.\nfunc (s *Skiplist) MemSize() int64 { return s.arena.size() }\n\n// Iterator is an iterator over skiplist object. For new objects, you just\n// need to initialize Iterator.list.\ntype SkipListIterator struct {\n\tlist *Skiplist\n\tn    *node\n}\n\nfunc (s *SkipListIterator) Rewind() {\n\ts.SeekToFirst()\n}\n\nfunc (s *SkipListIterator) Item() Item {\n\treturn &Entry{\n\t\tKey:       s.Key(),\n\t\tValue:     s.Value().Value,\n\t\tExpiresAt: s.Value().ExpiresAt,\n\t\tMeta:      s.Value().Meta,\n\t\tVersion:   s.Value().Version,\n\t}\n}\n\n// Close frees the resources held by the iterator\nfunc (s *SkipListIterator) Close() error {\n\ts.list.DecrRef()\n\treturn nil\n}\n\n// Valid returns true iff the iterator is positioned at a valid node.\nfunc (s *SkipListIterator) Valid() bool { return s.n != nil }\n\n// Key returns the key at the current position.\nfunc (s *SkipListIterator) Key() []byte {\n\t//implement me here\n}\n\n// Value returns value.\nfunc (s *SkipListIterator) Value() ValueStruct {\n\t//implement me here\n}\n\n// ValueUint64 returns the uint64 value of the current node.\nfunc (s *SkipListIterator) ValueUint64() uint64 {\n\treturn s.n.value\n}\n\n// Next advances to the next position.\nfunc (s *SkipListIterator) Next() {\n\tAssertTrue(s.Valid())\n\ts.n = s.list.getNext(s.n, 0)\n}\n\n// Prev advances to the previous position.\nfunc (s *SkipListIterator) Prev() {\n\tAssertTrue(s.Valid())\n\ts.n, _ = s.list.findNear(s.Key(), true, false) // find <. No equality allowed.\n}\n\n// 找到 >= target 的第一个节点\nfunc (s *SkipListIterator) Seek(target []byte) {\n\t//implement me here\n}\n\n// 找到 <= target 的第一个节点\nfunc (s *SkipListIterator) SeekForPrev(target []byte) {\n\t//implement me here\n}\n\n//定位到链表的第一个节点\nfunc (s *SkipListIterator) SeekToFirst() {\n\t//implement me here\n}\n\n// SeekToLast seeks position at the last entry in list.\n// Final state of iterator is Valid() iff list is not empty.\nfunc (s *SkipListIterator) SeekToLast() {\n\ts.n = s.list.findLast()\n}\n\n// UniIterator is a unidirectional memtable iterator. It is a thin wrapper around\n// Iterator. We like to keep Iterator as before, because it is more powerful and\n// we might support bidirectional iterators in the future.\ntype UniIterator struct {\n\titer     *Iterator\n\treversed bool\n}\n\n// FastRand is a fast thread local random function.\n//go:linkname FastRand runtime.fastrand\nfunc FastRand() uint32\n\n// AssertTruef is AssertTrue with extra info.\nfunc AssertTruef(b bool, format string, args ...interface{}) {\n\tif !b {\n\t\tlog.Fatalf(\"%+v\", errors.Errorf(format, args...))\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/utils/skiplist.go b/utils/skiplist.go
--- a/utils/skiplist.go	
+++ b/utils/skiplist.go	
@@ -448,11 +448,13 @@
 // Key returns the key at the current position.
 func (s *SkipListIterator) Key() []byte {
 	//implement me here
+	return s.Key()
 }
 
 // Value returns value.
 func (s *SkipListIterator) Value() ValueStruct {
 	//implement me here
+	return s.value()
 }
 
 // ValueUint64 returns the uint64 value of the current node.
@@ -482,7 +484,7 @@
 	//implement me here
 }
 
-//定位到链表的第一个节点
+// 定位到链表的第一个节点
 func (s *SkipListIterator) SeekToFirst() {
 	//implement me here
 }
@@ -502,6 +504,7 @@
 }
 
 // FastRand is a fast thread local random function.
+//
 //go:linkname FastRand runtime.fastrand
 func FastRand() uint32
 
